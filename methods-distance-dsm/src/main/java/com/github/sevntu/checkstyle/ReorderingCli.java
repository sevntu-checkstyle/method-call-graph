package com.github.sevntu.checkstyle;

import com.github.sevntu.checkstyle.analysis.Dependencies;
import com.github.sevntu.checkstyle.analysis.DependencyInformationConsumer;
import com.github.sevntu.checkstyle.check.MethodCallDependencyModule;
import com.github.sevntu.checkstyle.common.MethodCallDependencyCheckInvoker;
import com.github.sevntu.checkstyle.ordering.Ordering;
import com.github.sevntu.checkstyle.reordering.TopologicalMethodReorderer;
import com.github.sevntu.checkstyle.utils.FileUtils;
import com.github.sevntu.checkstyle.vizualization.DependencyInfoMatrixSerializer;
import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
import com.puppycrawl.tools.checkstyle.api.Configuration;

import java.io.File;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Application entry point that accepts file path and generates
 * DSM for initial methods ordering of class and DSM for method
 * ordering generated by topological sorting algorithm.
 */
public final class ReorderingCli {

    private ReorderingCli() { }

    public static void main(String... args) throws CheckstyleException {

        final Map<String, String> attributes = Collections.singletonMap("screenLinesCount", "50");

        final DependencyInformationSerializer consumer = new DependencyInformationSerializer();

        final MethodCallDependencyCheckInvoker runner =
            new MethodCallDependencyCheckInvoker(attributes, consumer);

        consumer.setConfig(runner.getConfiguration());

        final List<File> files = Collections.singletonList(new File(args[0]));
        runner.invoke(files);
    }

    private static final class DependencyInformationSerializer implements
        DependencyInformationConsumer {

        private Optional<Configuration> config = Optional.empty();

        private DependencyInformationSerializer() { }

        public void setConfig(final Configuration config) {
            this.config = Optional.of(config);
        }

        @Override
        public void accept(
            MethodCallDependencyModule check, String filePath, Dependencies dependencies) {

            config.ifPresent(configuration -> {
                final String baseName = new File(filePath).getName();
                final String source = FileUtils.getFileContents(filePath);
                final Ordering initialOrdering = new Ordering(dependencies);
                final Ordering topologicalOrdering = new TopologicalMethodReorderer()
                    .reorder(initialOrdering);
                DependencyInfoMatrixSerializer.writeToFile(
                    source, initialOrdering, configuration, baseName + ".initial.html");
                DependencyInfoMatrixSerializer.writeToFile(
                    source, topologicalOrdering, configuration, baseName + ".topological.html");
            });
        }
    }
}
